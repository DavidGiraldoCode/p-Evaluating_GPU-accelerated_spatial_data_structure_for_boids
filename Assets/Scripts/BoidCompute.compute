#pragma kernel CSMain
#pragma kernel CS_ObstacleAvoidance

static const int threadGroupSize = 1024;

// Simplified version of the boid
struct Boid {
    float3 position;
    float3 direction;

    float3 flockHeading;
    float3 flockCentre;
    float3 separationHeading;
    float3 obstacleAvoidanceHeading; //NEW

    int numFlockmates; 
    int numDetectedObstacles; // NEW
};

RWStructuredBuffer<Boid> boids;


// ----------------------------------------
RWStructuredBuffer<float3> obstacles;
RWStructuredBuffer<int2> _PivotsTableBuffer;
RWStructuredBuffer<int2> _HashedObstacleNodes;
float3 _BoundsExtent, _VoxelResolution;


int numBoids;
//int numObstacles;

float viewRadius;
float avoidRadius;

int hash(float3 worldPosition)
{
    float3 pos = worldPosition  % (_BoundsExtent * 2.0);
    pos.xz += _BoundsExtent.xz; 
    pos /= _BoundsExtent * 2;
    pos *= _VoxelResolution;

    return pos.x + pos.y * _VoxelResolution.x + pos.z * _VoxelResolution.x * _VoxelResolution.y;
}

/**
*  @brief For each thread, traverse the buffer array, counting how many boid are within range (distance check)
*  Then, if within range, increase the neighbour
*  Add the position of that neighbour to the flockCentre accumulator
*  Add the direction of that neighbour to the flockHeading accumulator
*  Also, check for neighbour that are too close (avoidRadius)
*  Add the inverse direction where the neighbour is
*/
[numthreads(threadGroupSize,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    for (int indexB = 0; indexB < numBoids; indexB ++) {
        if (id.x != indexB) { // Avoid computing with it self
            Boid boidB = boids[indexB];
            float3 offset = boidB.position - boids[id.x].position; // Distance between the current boid and other boid
            float sqrDst = offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;

            if (sqrDst < viewRadius * viewRadius) { // If it is within range
                // Accumulates the data on the current working thread, while iterate on the buffer.
                boids[id.x].numFlockmates += 1;     // Acounted as relevant fro the steering forces average
                boids[id.x].flockHeading += boidB.direction;
                boids[id.x].flockCentre += boidB.position;

                if (sqrDst < avoidRadius * avoidRadius) {
                    // Normalizes the direction where the neighbour is, and inver the direction for avoidance
                    boids[id.x].separationHeading -= offset / sqrDst;
                }
            }
            //
            /*
            for(int i_obs = 0; i_obs < numObstacles; i_obs++)
            {
                float3 boidToObstacle = obstacles[i_obs] - boids[id.x].position;
                float  sqrDistToObs   =  boidToObstacle.x * boidToObstacle.x + boidToObstacle.y * boidToObstacle.y + boidToObstacle.z * boidToObstacle.z;
                float  criticalDistance = 1.5f;
                if(sqrDistToObs < criticalDistance * criticalDistance)
                {
                    boids[id.x].numDetectedObstacles += 1;
                    boids[id.x].obstaclesSeparationHeading -= boidToObstacle/sqrDistToObs;
                }
            }
            */

        }
    }
}

[numthreads(threadGroupSize,1,1)]
void CS_ObstacleAvoidance (uint3 id : SV_DispatchThreadID)
{
    // Each thread ID represents a boid
    if(0 >= id.x && id.x < numBoids)
    {
       
        int voxel_location = hash(boids[id.x].position);
        int obstacleCountInVoxel = _PivotsTableBuffer[voxel_location].x;
        boids[id.x].numDetectedObstacles = obstacleCountInVoxel;
        
        
        if(obstacleCountInVoxel > 0) // There are obstacle in the current voxel
        {
            int obstacle_in_stack = _PivotsTableBuffer[voxel_location].y;
            int next = 0;
            
            while(next != -1)
            {
            //     //obstacles[obstacle_in_stack]; // Getting the position of the obstacle in the voxel

             //    float3 boidToObstacle = obstacles[obstacle_in_stack] - boids[id.x].position;
             //    float  sqrDistToObs   =  boidToObstacle.x * boidToObstacle.x + boidToObstacle.y * boidToObstacle.y + boidToObstacle.z * boidToObstacle.z;
            //    float  criticalDistance = 1.5f;
                
            //     if(sqrDistToObs < criticalDistance * criticalDistance)
            //     {
            //         //boids[id.x].numDetectedObstacles += 1;
            //         //boids[id.x].obstacleAvoidanceHeading -= boidToObstacle/sqrDistToObs;
            //     }

                 //next = _HashedObstacleNodes[obstacle_in_stack].y;
                 //obstacle_in_stack = next;
            }
        }
            
    }
}